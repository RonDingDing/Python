# 实用的IP地址处理模块IPy
# 在IP地址规划中，涉及到计算大量的IP地址，包括网段、网络掩码、广播地址、子网数、IP类型等

# 别担心，Ipy模块拯救你。Ipy模块可以很好的辅助我们高效的完成IP的规划工作。

# 源码方式安装Ipy模块
# $ wget https://pypi.python.org/packages/source/I/IPy/IPy-0.81.tar.gz --no-check-certificate
# $ tar zxvf IPy-0.81.tar.gz
# $ cd IPy-0.81/
# $ sudo python setup.py install
# IP地址、网段的基本处理
# IPy模块包含IP类，使用它可以方便处理绝大部分格式为IPv6的网络和地址

# 比如通过version方法来区分出IPv4和IPv6

# >>> import IPy
# >>> IPy.IP('10.0.0.0/8').version()
# 4
# >>> IPy.IP('::1').version()
# 6
# 通过指定的网段输出该网段的IP个数和所有的IP地址清单

# 如下：

# $ more ip.py 
#!/usr/bin/env python
# import IPy

# ip = IPy.IP('192.168.0.0/16')
# print ip.len()
# for x in ip:
#     print x


# 反向解析名称、IP类型、IP转换等

# >>> ip = IP('192.168.1.20')
# >>> ip.reverseNames()               #反向解析地址格式
# ['20.1.168.192.in-addr.arpa.']
# >>> ip.iptype()                     #私网类型
# 'PRIVATE'
# >>> IP('8.8.8.8').iptype()          #公网类型
# 'PUBLIC'
# >>> IP('8.8.8.8').int()             #转换为整型格式
# 134744072
# >>> IP('8.8.8.8').strHex()          #转换为十六进制格式
# '0x8080808'
# >>> IP('8.8.8.8').strBin()          #转换成二进制格式
# '00001000000010000000100000001000'
# >>> print IP('0x8080808')           #十六进制转换为IP格式
# 8.8.8.8
# >>> print IP(134744072)             #整型格式转换为IP格式
# 8.8.8.8
# IP方法也支持网络地址的转换，例如根据IP和掩码产生网段格式

# >>> print (IP('192.168.1.0').make_net('255.255.255.0'))
# 192.168.1.0/24
# >>> print (IP('192.168.1.0/255.255.255.0',make_net=True))
# 192.168.1.0/24
# >>> print (IP('192.168.1.0-192.168.1.255',make_net=True))
# 192.168.1.0/24
# 通过strNormal方法指定不同wantprefixlen参数值以定制不同输出类型的网段，输出类型为字符串

# >>> IP('192.168.1.0/24').strNormal(0)   #无返回
# '192.168.1.0'
# >>> IP('192.168.1.0/24').strNormal(1)   #prefix格式
# '192.168.1.0/24'
# >>> IP('192.168.1.0/24').strNormal(2)   #decimalnetmask格式
# '192.168.1.0/255.255.255.0'
# >>> IP('192.168.1.0/24').strNormal(3)   #lastIP格式
# '192.168.1.0-192.168.1.255'
# 多网络计算方法详解
# 比较两个网段是否存在包含、重叠等关系，比如同网络但不同prefixlen会认为是不相等的网段，如10.0.0.0/16不等于10.0.0.0/24，另外即使具有相同的prefixlen但处于不同的网络地址，同样也视为不相等，如10.0.0.0/16不等于192.0.0.0/16。IPy支持类似于数值型数据的比较，以帮助IP对象进行比较。

# 比较IP大小

# >>> IP('10.0.0.0/24') < IP('12.0.0.0/24')
# True
# 判断IP地址和网段是否包含于另一个网段中

# >>> '192.168.1.100' in IP('192.168.1.0/24')
# True
# >>> IP('192.168.1.0/24') in IP('192.168.0.0/16')
# True
# 判断两个网段是否存在重叠（overlaps方法）

# >>> IP('192.168.0.0/23').overlaps('192.168.1.0/24')
# 1
# >>> IP('192.168.1.0/24').overlaps('192.168.2.0/24')
# 0
