# Generated by Selenium IDE
from __future__ import annotations
import time
import configparser
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.remote.webelement import WebElement
import os
from typing import Any
import threading
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import sys


class ConfigException(Exception):
    pass


class RunningException(Exception):
    pass


class TestApple:
    def __init__(self) -> None:
        self.setup_method()

    def setup_method(self) -> None:
        self.vars = {}
        self.options = self.read_options()

        self.main_driver = webdriver.Chrome(ChromeDriverManager().install())
        self.lock = threading.Lock()
        self.thread_pool = ThreadPoolExecutor(min(5, self.options["driver_thread_num"]))

    def read_op(
        self,
        cp: dict | configparser.ConfigParser,
        keys: str,
        convert_type: type = None,
        except_str: str = "",
        start_error_key: str = "",
    ) -> Any:
        try:
            k = keys.split(".")
            cur = cp
            error_key = start_error_key
            for i in k:
                error_key += "." + i
                cur = cur[i]
            if convert_type is not None:
                cur = convert_type(cur)
            return cur
        except KeyError:
            error_key = error_key.lstrip(".")
            except_str = except_str if except_str else "不存在"
            raise ConfigException(f"config.ini->{error_key} {except_str}")
        except Exception:
            error_key = error_key.lstrip(".")
            raise ConfigException(f"config.ini->{error_key} {except_str}")

    def read_options(self) -> dict:
        cp = configparser.ConfigParser()
        cp.read("config.ini", encoding="utf-8")
        for w in "Driver", "Frequency", "Public", "Types":
            if w not in cp:
                raise ConfigException(f"config.ini->{w} 不存在")

        public_targets = [
            i.strip('"').strip("'")
            for i in self.read_op(cp, "Public.targets").split(",")
        ]
        public_scrap_num = self.read_op(cp, "Public.scrap_num", int, "不是有效数字")
        types_types = self.read_op(cp, "Types.types").split()
        driver_timeout = self.read_op(cp, "Driver.timeout", int, "不是有效数字")
        frequency_num = self.read_op(cp, "Frequency.num", int, "不是有效数字")
        unit_dic = {
            "minute": 60,
            "hour": 60 * 60,
            "day": 60 * 60 * 24,
            "week": 60 * 60 * 24 * 7,
        }

        frequency_unit = self.read_op(cp, "Frequency.unit")
        unit = self.read_op(
            unit_dic,
            frequency_unit,
            except_str="不是有效单位，请改成minute,hour,day,week其中之一",
            start_error_key="Frequency.unit",
        )
        interval = frequency_num * unit
        driver_thread_num = self.read_op(cp, "Driver.thread_num", int)
        output_folder = os.path.join(self.read_op(cp, "Public.output"), "output")
        if os.path.isfile(output_folder):
            raise TypeError("config.ini->Public->output指定的路径是个文件。")
        elif not os.path.exists(output_folder):
            os.makedirs(output_folder)
        return {
            "public_targets": public_targets,
            "public_scrap_num": public_scrap_num,
            "public_output_folder": output_folder,
            "types_types": types_types,
            "driver_timeout": driver_timeout,
            "driver_thread_num": driver_thread_num,
            "frequency_interval": interval,
        }

    def teardown_method(self) -> None:
        pass

    def wait_for_shown(self, driver: webdriver.Chrome, by, ele) -> WebElement:
        element = WebDriverWait(driver, timeout=self.options["driver_timeout"]).until(
            lambda driver: driver.find_element(by, ele)
        )
        return element

    def wait_for_shown_all(
        self, driver: webdriver.Chrome, by: str, ele
    ) -> list[WebElement]:
        elements = WebDriverWait(driver, timeout=self.options["driver_timeout"]).until(
            lambda driver: driver.find_elements(by, ele)
        )
        return elements

    def read_or_write_csv(self, tup: tuple[str, ...]) -> None:
        with self.lock:
            public_name, date, title, link, types_str = tup
            one = f"{public_name}, {date}, {title}, {link}, {types_str}\n"
            filename = f"{self.options['public_output_folder']}/{date}.csv"
            if os.path.isfile(filename):
                has = False
                with open(filename, "r", encoding="utf-8") as f1:
                    content = f1.read()
                for line in content.split("\n"):
                    ss = line.split(", ")
                    if len(ss) >= 3 and ss[2] == title:
                        has = True
                        break
                if not has:
                    with open(filename, "a", encoding="utf-8") as f2:
                        f2.write(one)

            elif os.path.isdir(filename):
                os.removedirs(filename)
                with open(filename, "w", encoding="utf-8") as f:
                    f.write("公众号, 日期, 标题, 链接, 类别\n")
                    f.write(one)
            else:
                with open(filename, "w", encoding="utf-8") as f:
                    f.write("公众号, 日期, 标题, 链接, 类别\n")
                    f.write(one)

    def run(self) -> None:
        while True:
            try:
                self.main_driver.get("https://mp.weixin.qq.com")
                self.main_driver.maximize_window()
                self.wait_for_shown(self.main_driver, By.LINK_TEXT, "草稿箱")
                self.vars["root"] = self.main_driver.current_window_handle
                targets = self.options["public_targets"]
                for t in targets:
                    self.crawl(t)
                self.main_driver.close()
                time.sleep(self.options["frequency_interval"])
            except Exception as e:
                with open(
                    f"{self.options['public_output_folder']}/error.txt", "a"
                ) as f:
                    f.write(f"{type(Exception)}:{e}\n")
                    sys.exit()

    def switch_to_new_window(self, driver: webdriver.Chrome):
        while len(driver.window_handles) == 1:
            time.sleep(1)
        driver.switch_to.window(driver.window_handles[-1])

    def crawl(self, public_name: str) -> None:
        driver = self.main_driver
        driver.switch_to.window(self.vars["root"])
        self.wait_for_shown(driver, By.LINK_TEXT, "草稿箱").click()
        self.wait_for_shown(
            driver, By.CLASS_NAME, "weui-desktop-card__icon-add"
        ).click()

        self.wait_for_shown(driver, By.LINK_TEXT, "写新图文").click()

        self.switch_to_new_window(driver)

        self.wait_for_shown(driver, By.ID, "js_editor_insertlink").click()
        driver.find_element(
            By.CSS_SELECTOR, ".weui-desktop-link-btn > .weui-desktop-btn"
        ).click()
        driver.find_element(
            By.CSS_SELECTOR, ".weui-desktop-search__wrp .weui-desktop-form__input"
        ).click()
        driver.find_element(
            By.CSS_SELECTOR, ".weui-desktop-search__wrp .weui-desktop-form__input"
        ).send_keys(public_name)
        driver.find_element(
            By.CSS_SELECTOR, ".weui-desktop-search__btn:nth-child(2)"
        ).click()
        self.wait_for_shown(
            driver,
            By.CSS_SELECTOR,
            ".inner_link_account_item > .weui-desktop-vm_primary",
        ).click()
        scrap_num = 0
        real_public_name = (
            self.wait_for_shown(driver, By.CSS_SELECTOR, "p.inner_link_account_msg")
            .text.replace("选择其他公众号","")
            .strip()
        )

        while True:
            for i in self.wait_for_shown_all(
                driver, By.CLASS_NAME, "inner_link_article_item"
            ):
                i.click()
                title, date, *_ = i.text.split("\n")
                a = i.find_element(By.TAG_NAME, "a")
                link = a.get_attribute("href")
                types_str = self.make_type_str(title)
                self.read_or_write_csv((real_public_name, date, title, link, types_str))
                scrap_num += 1
                time.sleep(0.5)
                if scrap_num >= self.options["public_scrap_num"]:
                    break
            if scrap_num >= self.options["public_scrap_num"]:
                break
            driver.find_element(By.LINK_TEXT, "下一页").click()
        self.main_driver.close()

    def make_type_str(self, title: str) -> str:
        types_str_list = []
        for t in self.options["types_types"]:
            if t in title:
                types_str_list.append(t)
        return "|".join(types_str_list)


if __name__ == "__main__":
    TestApple().run()
